package de.uniba.sme.bambirds.planner.physicssimulation.scene.modification.randomisation;

import java.util.Random;

import de.uniba.sme.bambirds.planner.physicssimulation.scene.Scene;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.SceneEntity;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.SceneEntityBase;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.ScenePolygon;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.modification.ISceneModifier;

import org.jbox2d.common.Vec2;

public class PositionRandomizer implements ISceneModifier {
    
    private float maxXOffset;
    private float maxYOffset;

    private Random rand = new Random();

    @Override public String toString() {
        return "position x=" + maxXOffset + "px y=" + maxYOffset + "px";
    }

    /**
     * Randomises x/y position for each entity to simulate vision inaccuracies.
     * Changes center positions for every SceneEntity except for polygons. For polygons each vertex position is randomised.
     * Input refers to pixel values (there apply this modifier directly to Scene generated by Vision).
     * Randomisation adds a value from [-maxOffset; maxOffset] to the original data (continuos range).
     * 
     * @param maxXOffset x offset (in pixels)
     * @param maxYOffset y offset (in pixels)
     */
    public PositionRandomizer(float maxXOffset, float maxYOffset) {
        this.maxXOffset = maxXOffset;
        this.maxYOffset = maxYOffset;
    }


    public void apply(Scene scene) {
        for(SceneEntityBase entity: scene.getAllEntities()) {
            //for Polygons, change each vertex by x/y, not entire Poly position
            if (entity instanceof ScenePolygon) {
                ScenePolygon poly = (ScenePolygon) entity;
                Vec2[] vertices = poly.getVertices();
                for (int i = 0; i < vertices.length; i++) {
                    vertices[i].x += getNextXOffset();
                    vertices[i].y += getNextYOffset();
                }
            } else {
                float newX = entity.getCenterX() + getNextXOffset();
                float newY = entity.getCenterY() + getNextYOffset();
                entity.setCenterPosition(newX, newY);
            }
        }
    }

    private float getNextXOffset() {
        float offset = rand.nextFloat() * (float) maxXOffset;

        if (rand.nextBoolean()) {
            offset *= -1.0f;
        }

        return offset;
    }

    private float getNextYOffset() {
        float offset = rand.nextFloat() * (float) maxYOffset;

        if (rand.nextBoolean()) {
            offset *= -1.0f;
        }

        return offset;
    }

}
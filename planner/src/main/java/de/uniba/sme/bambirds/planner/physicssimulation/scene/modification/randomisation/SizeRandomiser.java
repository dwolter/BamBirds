package de.uniba.sme.bambirds.planner.physicssimulation.scene.modification.randomisation;

import java.util.Random;

import de.uniba.sme.bambirds.planner.physicssimulation.scene.Scene;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.SceneCircle;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.SceneEntityBase;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.ScenePolygon;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.entities.SceneRectangle;
import de.uniba.sme.bambirds.planner.physicssimulation.scene.modification.ISceneModifier;

public class SizeRandomiser implements ISceneModifier {

    private float maxXOffset;

    private Random rand = new Random();

    @Override public String toString() {
        return "size=" + maxXOffset + "px";
    }

    /**
     * Randomises width/height/radius for each entity in order to simulate vision
     * inaccuracies. Does not change polygons. Input refers to pixel values (there
     * apply this modifier directly to Scene generated by Vision). Randomisation
     * adds a value from [-maxOffset; maxOffset] to the original data (continuos
     * range).
     * 
     * @param maxOffset x offset (in pixels)
     */
    public SizeRandomiser(float maxOffset) {
        this.maxXOffset = maxOffset;
    }

    public void apply(Scene scene) {
        for (SceneEntityBase entity : scene.getAllEntities()) {
            // for Polygons, change each vertex by x/y, not entire Poly position
            if (entity instanceof ScenePolygon) {
                continue;
            } else if (entity instanceof SceneRectangle) {
                SceneRectangle rect = (SceneRectangle) entity;
                float newWidth = rect.getWidth() + getNextOffset();
                float newHeight = rect.getHeight() + getNextOffset();
                rect.setWidth(newWidth);
                rect.setHeight(newHeight);
            } else if (entity instanceof SceneCircle) {
                SceneCircle circle = (SceneCircle) entity;
                float newRadius = circle.getRadius() + getNextOffset();
                circle.setRadius(newRadius);
            }
        }
    }

    private float getNextOffset() {
        float offset = rand.nextFloat() * maxXOffset;

        if (rand.nextBoolean()) {
            offset *= -1.0f;
        }

        return offset;
    }

}